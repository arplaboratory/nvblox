# NvBlox
NvBlox package for ROS 2 Humble based online mapping for the Agile Robotics and Perception Lab.

## Prerequisites
1) ROS 2 Humble
2) CUDA
3) CMake version >= 3.22
## Common issues while building
### 1) CMake version is too low
At the time of this writing, the lab uses JetPack 5.1.2, which installs CMake version 3.16.3 by default. Please check the CMake version by running the command:
```
cmake --version
```
### 2) The CUDA compiler identification is unknown. Failed to detect a default CUDA architecture.
This occurs because CMake couldn't find the Nvidia CUDA compiler (NVCC).
1. Make sure you have installed CUDA. You can see if its installed by running 
```
jtop
```
and navigating to the INFO section where the CUDA version is displayed. If the CUDA version is not displayed and instead says NO, it means CUDA is not installed.

2. Make sure the PATH variable in the environment contains the path to where the CUDA compiler (NVCC) is installed. You can see if this is the case by running the command:
```
nvcc --version
```
If the command returns: 
`
bash: nvcc: command not found
`
it means the PATH variable does not contain the path to where the CUDA compiler is installed. Usually, it is installed in 
`
/usr/local/<your_cuda_version>/bin
`
Find the location of the NVCC compiler and add it to the PATH variable in the bash scipt
```
export PATH=/usr/local/<your_cuda_version>/bin:$PATH
```
Source the bash script and run `nvcc --version` again. It should display the version of your NVCC compiler now.

### 3) CMAKE_CUDA_ARCHITECTURES must be non-empty if set
This is related to the previous error. After resolving the previous issue, clean the build and install directories of any nvblox packages and build again. 

### 4) Nav2 not found
NvBlox interfaces with ROS 2's navigation stack called Nav2. Since we don't use Nav2, place a COLCON_IGNORE script inside the nvblox_nav2 package (This should already be there in this repo).

## Issues while running
If NvBlox doesn't output anything, its usually one of these three things:
1. Incorrect or incomplete TF trees: Make sure that the `pose_frame` and the `global_frame` parameters are set properly and there exists a valid transformation between the two frames. Vanilla NvBlox typically uses three frames; the global and pose frames set by the user, and the sensor frame, which it gets from the image_depth topic. Our version of NvBlox does not use the sensor frame, and instead relies solely on the two frames set by the user in the launch file.
2. Incorrect depth topic or bad depth image: NvBlox uses the depth map (usually generated by the RealSense depth module, but in our case, generated by the disparity nodelet) to create the 3D environment. Make sure NvBlox is receiving the depth maps and they are of the correct format. NvBlox requires that the depth maps be an image with the encoding CV_16UC1 (unsigned 16 bit, single channel) and the values inside range from 0 (indicating very close or invalid readings) to 65535 (the maximum possible distance). Make sure the images fed into NvBlox match these specifications.
3. Incorrect camera_info_topic: NvBlox also uses the metadata from the `/cam1/infra1/camera_info` topic to construct the 3D scene. Make sure this topic is sending data to NvBlox.

